<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skyscraper Jumper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Changed to Inter font */
            background-color: #000; /* Changed to black background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Default to hidden */
            position: relative;
            flex-direction: column; /* Ensure vertical stacking for game and controls */
        }

        @keyframes pulse-yellow-glow {
            0% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 215, 0, 1); }
            100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
        }

        /* Collectible animation (up and down bounce) */
        @keyframes collectible-jump {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); } /* Bounces 10px up */
        }

        .game-container {
            position: relative;
            width: 100%; /* Default to 100% width */
            max-width: 800px; /* Limit max width on larger screens */
            aspect-ratio: 800 / 600; /* Set aspect ratio (width / height) based on original desktop dimensions */
            background-image: url(https://d39-a.sdn.cz/d_39/c_img_QP_z/TluK/jizni-mesto-sidliste.jpeg?fl=cro,266,93,864,486%7Cres,1200,,1);
            background-size: cover; /* Cover the entire container */
            background-position: center; /* Center the background image */
            border-radius: 0; /* Removed border-radius */
            overflow: hidden;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.7); /* Stronger shadow */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            border: 4px solid #888; /* Lighter gray retro border */
        }

        .cityscape {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Covers the entire game area */
            background-color: rgba(0, 0, 0, 0.2); /* Subtle dark overlay to make buildings stand out */
            background-size: cover;
            background-position: bottom;
            z-index: 1;
            /* Add some parallax effect */
            transform: translateY(0);
            transition: transform 0.1s linear;
        }

        .building {
            position: absolute;
            bottom: 0;
            background-color: #7a7366; /* User's specified brownish-gray for buildings */
            border-radius: 0; /* Sharp corners for retro buildings */
            border: 2px solid #333; /* Darker border */
            box-shadow: inset -3px 6px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }

        .building-window {
            background-color: #5D616b; /* User's specified darker gray/blue-gray for windows */
            border: 1px solid #777777; /* Darker gray border for windows */
            position: absolute;
            box-shadow: none; /* No glow for daytime windows */
            border-radius: 0; /* Sharp corners for windows */
            transition: background-color 0.5s ease-in-out; /* Smooth transition for color change */
        }

        .building-window.yellow { /* New style for dangerous windows */
            background-color: #FFD700; /* Yellow for dangerous windows */
            border: 1px solid #C4A400;
            animation: pulse-yellow-glow 1.5s infinite alternate; /* Pulsing glow */
        }

        #player {
            position: absolute;
            bottom: 0;
            left: 50px;
            width: 80px; /* Width for image character - base for desktop, overridden by media query for mobile */
            height: 120px; /* Height for image character - base for desktop, overridden by media query for mobile */
            background-image: url('https://cdn.shopify.com/s/files/1/0937/6061/8760/files/Cbloc_game_character_polo.png?v=1751808174'); /* NEW character image */
            background-size: contain; /* Ensure image fits within bounds */
            background-repeat: no-repeat;
            background-position: center;
            border: none; /* No border for image character */
            border-radius: 0;
            transition: transform 0.2s ease-out, bottom 0.2s ease-out, left 0.2s ease-out;
            z-index: 10;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8); /* Dark background */
            color: #FFFFFF; /* White text */
            padding: 10px 20px;
            border-radius: 0; /* Removed border-radius */
            font-size: 1.5rem;
            z-index: 20;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            border: 2px solid #888888; /* Gray border */
        }

        .collectible {
            position: absolute;
            bottom: 0; /* Will be adjusted to sit on building */
            z-index: 5; /* Above buildings, below player */
            animation: collectible-jump 1.5s infinite ease-in-out; /* Apply jumping animation */
            object-fit: contain;
        }

        .crackhead {
            position: absolute;
            bottom: 0;
            background-image: url('https://cdn.shopify.com/s/files/1/0937/6061/8760/files/crackhead.png?v=1751871379');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 9; /* Below player, above buildings */
            /* Initial size, will be overridden by JS for dynamic sizing */
            width: 80px; 
            height: 120px;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #111; /* Dark background */
            color: #FFFFFF; /* White text */
            padding: 30px;
            border-radius: 0; /* Removed border-radius */
            text-align: center;
            font-size: 1.5rem;
            z-index: 30;
            box-shadow: 0 0 20px rgba(200, 200, 200, 0.7); /* Lighter gray glowing shadow */
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 20px;
            border: 4px solid #888888; /* Gray retro border */
        }

        .message-box input {
            padding: 10px;
            font-size: 1rem;
            border: 2px solid #555;
            background-color: #333;
            color: white;
            border-radius: 0;
            margin-top: 10px;
        }

        .message-box button, .mobile-controls button, .action-button { /* Consolidated button styling */
            font-family: 'Inter', sans-serif; /* Apply Inter font to buttons */
            background-color: #555; /* Darker gray button */
            color: white;
            padding: 10px 20px;
            border: 2px solid #333; /* Even darker gray border */
            border-radius: 0; /* Removed border-radius */
            cursor: pointer;
            font-size: 1.2rem;
            transition: background-color 0.1s ease, transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 4px 0 0 rgba(0,0,0,0.5); /* Push effect */
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3); /* Pixelated text shadow */
        }

        .message-box button:hover, .mobile-controls button:hover, .action-button:hover { /* Consolidated button styling */
            background-color: #777; /* Lighter gray on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 0 0 rgba(0,0,0,0.5);
        }
        .message-box button:active, .mobile-controls button:active, .action-button:active { /* Consolidated button styling */
            transform: translateY(2px);
            box-shadow: 0 0px 0 0 rgba(0,0,0,0.5);
        }

        .top-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px; /* Space between buttons and game container */
        }

        .mobile-controls {
            margin-top: 20px; /* Add space between game and buttons */
            display: flex;
            gap: 15px;
            z-index: 25;
            display: none; /* Hidden by default, shown on small screens */
            width: 90%;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mobile-controls button {
            padding: 20px 30px;
            font-size: 1.8rem;
            flex: 1;
            min-width: 100px;
            max-width: 150px;
        }

        /* Styling for the cover image when used as background */
        .game-container.start-screen-cover {
            background-image: url('https://cdn.shopify.com/s/files/1/0937/6061/8760/files/Cbloc_game_cover.png?v=1751878126');
            background-size: cover;
            background-position: center;
        }

        /* Specific styling for the start screen message box */
        .message-box.start-screen {
            background-color: rgba(0, 0, 0, 0.7); /* Slightly transparent dark background */
            border: 4px solid #888888;
            padding: 40px;
        }

        .message-box.start-screen #messageText {
            font-size: 2.5rem; /* Larger font for title */
            font-weight: bold;
            margin-bottom: 10px;
            line-height: 1.2;
        }
        .message-box.start-screen #start-instruction {
            font-size: 1.5rem;
            margin-top: 10px;
            margin-bottom: 30px;
        }
        .message-box.start-screen #prize-text {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        /* New Instagram Share Modal Styling */
        .instagram-share-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 90vh; /* Changed to height for 9:16 aspect ratio */
            max-height: 900px; /* Max height for desktop */
            aspect-ratio: 9 / 16; /* Key for 9:16 aspect ratio (height / width) */
            background-image: url('https://cdn.shopify.com/s/files/1/0937/6061/8760/files/Cbloc_game_cover.png?v=1751878126'); /* Reusing existing cover image */
            background-size: cover;
            background-position: center;
            border-radius: 10px; /* Slightly rounded corners for aesthetics */
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 40; /* Higher z-index than message-box */
            display: none; /* Hidden by default */
            padding: 20px; /* Internal padding */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); /* Text shadow for readability on image */
        }

        .instagram-share-modal .modal-content {
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent overlay for text readability */
            padding: 20px 30px;
            border-radius: 8px;
        }

        .instagram-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 2.5rem;
            color: white;
            background: none;
            border: none;
            cursor: pointer;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 41;
        }

        /* Fullscreen button specific styling */
        .fullscreen-button {
            margin-top: 20px; /* Space below content */
            padding: 10px 20px;
            font-size: 1.1rem;
            background-color: #4CAF50; /* Green color for fullscreen */
            color: white;
            border: 2px solid #2e8b57;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.1s ease, transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 4px 0 0 rgba(0,0,0,0.5);
        }

        .fullscreen-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 0 rgba(0,0,0,0.5);
        }

        .fullscreen-button:active {
            transform: translateY(2px);
            box-shadow: 0 0px 0 0 rgba(0,0,0,0.5);
        }


        @media (max-width: 768px) {
            body {
                overflow: hidden; /* Prevent horizontal scrolling on body for mobile */
            }
            .game-container {
                width: 100%; /* Ensure it's 100% on mobile */
                aspect-ratio: 800 / 600; /* Maintain the desktop aspect ratio */
                border-radius: 0;
            }
            .mobile-controls {
                display: flex;
            }
            #player {
                width: 10vw; /* Adjust player size for mobile proportionally */
                height: 15vw; /* Maintain aspect ratio for player */
            }
            .crackhead {
                width: 10vw; /* Adjust crackhead size for mobile proportionally */
                height: 15vw; /* Maintain aspect ratio for crackhead */
            }
            .collectible {
                width: 5vw; /* Adjust collectible size for mobile proportionally */
                height: 5vw; /* Maintain aspect ratio for collectible */
            }
            #score-display {
                font-size: 0.9rem; /* Adjusted font size for mobile score */
                padding: 5px 10px;
            }
            .message-box {
                width: 90%; /* Adjust message box width for mobile */
                max-width: 95vw; /* Ensure it doesn't exceed viewport width */
                font-size: 0.75rem; /* Further reduced font size for general messages */
                padding: 8px; /* Further reduced padding */
                gap: 8px; /* Reduced gap between elements in message box */
                box-sizing: border-box; /* Ensure padding is included in width */
            }
            .message-box input {
                padding: 6px; /* Smaller input padding */
                font-size: 0.8rem; /* Smaller input font size */
            }
            .message-box button, .mobile-controls button, .action-button { /* Consolidated button styling */
                padding: 8px 12px; /* Smaller button padding */
                font-size: 0.9rem; /* Smaller button font size */
            }
            .mobile-controls button {
                padding: 15px 20px; /* Slightly larger for mobile controls for easier tapping */
                font-size: 1.2rem;
            }
            .message-box.start-screen {
                padding: 20px; /* Reduced padding for start screen message box */
            }
            .message-box.start-screen #messageText {
                font-size: 1.3rem; /* Adjusted font size for start screen title */
                margin-bottom: 5px; /* Reduced margin */
            }
            .message-box.start-screen #start-instruction {
                font-size: 0.75rem; /* Adjusted font size for start instruction */
                margin-top: 5px; /* Reduced margin */
                margin-bottom: 10px; /* Reduced margin */
            }
            .message-box.start-screen #prize-text {
                font-size: 0.65rem; /* Adjusted font size for prize text */
                margin-bottom: 10px; /* Reduced margin */
            }
            #deathReasonDisplay, #finalScoreDisplay, #timePlayedDisplay {
                font-size: 0.85rem; /* Adjusted font size for game over details */
            }

            /* New Instagram Share Modal Mobile Styling */
            .instagram-share-modal {
                width: auto; /* Let height control width via aspect-ratio */
                height: 95vh; /* Slightly larger height on mobile */
                max-height: 95vh; /* Limit height */
                padding: 10px;
            }
            .instagram-share-modal .modal-content {
                padding: 15px 20px;
            }
            .instagram-share-modal h2 {
                font-size: 1.8rem;
            }
            .instagram-share-modal p {
                font-size: 1.2rem;
            }
            .instagram-share-modal p.text-sm {
                font-size: 0.75rem;
            }
            .instagram-close-button {
                font-size: 2rem;
                top: 5px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="top-buttons">
        <!-- Leaderboard Button -->
        <button id="leaderboardButton" class="action-button">Leaderboard</button>
        <!-- Play/Restart Button - Added next to leaderboard -->
        <button id="playRestartButton" class="action-button">Play</button>
    </div>

    <div class="game-container" id="gameContainer">
        <div class="cityscape" id="cityscape"></div>
        <div id="score-display">Score: 0</div>
        <div id="player"></div>

        <!-- Audio Element for background sound -->
        <audio id="gameAudio" src="https://cdn.shopify.com/s/files/1/0937/6061/8760/files/CHIEF_KEEF_-_3HUNNA_shot_by_DJKENNAON.mp3?v=1751807862" preload="auto"></audio>
        <!-- Audio Element for crackhead spawn sound -->
        <audio id="crackheadAudio" src="https://cdn.shopify.com/s/files/1/0937/6061/8760/files/Bouchla_Varna_mp3cut.net.mp3?v=1751870701" preload="auto"></audio>

        <!-- Message Box for game start / game over / leaderboard -->
        <div class="message-box" id="messageBox">
            <p id="deathReasonDisplay" class="hidden"></p> <!-- New element for death reason -->
            <p id="messageText"></p>
            <p id="finalScoreDisplay" class="hidden"></p> <!-- New element for final score -->
            <input type="text" id="instagramNicknameInput" placeholder="Zadejte svůj Instagram nickname" class="hidden">
            <button id="submitNicknameButton" class="hidden">Odeslat</button>
            <button id="startGameButton" class="hidden">Hrat o polo</button>
            <button id="restartGameButton" class="hidden">Restartovat hru</button>
            <p id="timePlayedDisplay" class="hidden"></p> <!-- Moved time display -->
            <p id="start-instruction" class="hidden"></p> <!-- New element for start instruction -->
            <p id="prize-text" class="hidden"></p> <!-- New element for prize text -->
            <button id="closeButton" class="hidden">Close</button> <!-- New close button for popups -->
        </div>
    </div>

    <!-- New Instagram Share Modal -->
    <div class="instagram-share-modal" id="instagramShareModal">
        <button id="instagramCloseButton" class="instagram-close-button">&times;</button>
        <div class="modal-content">
            <h2 class="text-white text-3xl font-bold mb-4">Your Game Summary!</h2>
            <p id="instagramScore" class="text-white text-2xl mb-2"></p>
            <p id="instagramTime" class="text-white text-xl"></p>
            <p class="text-white text-sm mt-4">Screenshot this and share on Instagram!</p>
            <!-- Removed the fullscreen button as requested -->
        </div>
    </div>

    <!-- Mobile Controls - Moved outside game-container -->
    <div class="mobile-controls">
        <button id="leftButton">Left</button>
        <button id="upButton">Up</button>
        <button id="rightButton">Right</button>
    </div>

    <script type="module">
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('gameContainer');
        const scoreDisplay = document.getElementById('score-display');
        const cityscape = document.getElementById('cityscape');
        const gameAudio = document.getElementById('gameAudio');
        const crackheadAudio = document.getElementById('crackheadAudio'); // Get crackhead audio element

        // Message Box elements
        const messageBox = document.getElementById('messageBox');
        const deathReasonDisplay = document.getElementById('deathReasonDisplay'); // New death reason element
        const messageText = document.getElementById('messageText');
        const finalScoreDisplay = document.getElementById('finalScoreDisplay'); // New final score element
        const timePlayedDisplay = document.getElementById('timePlayedDisplay'); // Get new time display element
        const startInstruction = document.getElementById('start-instruction'); // New start instruction element
        const prizeText = document.getElementById('prize-text'); // New prize text element
        const instagramNicknameInput = document.getElementById('instagramNicknameInput');
        const submitNicknameButton = document.getElementById('submitNicknameButton');
        const startGameButton = document.getElementById('startGameButton');
        const restartGameButton = document.getElementById('restartGameButton');
        const leaderboardButton = document.getElementById('leaderboardButton'); // Get leaderboard button
        const playRestartButton = document.getElementById('playRestartButton'); // Get the new play/restart button
        const closeButton = document.getElementById('closeButton'); // Get new close button

        // Instagram Share Modal elements
        const instagramShareModal = document.getElementById('instagramShareModal');
        const instagramCloseButton = document.getElementById('instagramCloseButton');
        const instagramScoreDisplay = document.getElementById('instagramScore');
        const instagramTimeDisplay = document.getElementById('instagramTime');
        // const fullscreenButton = document.getElementById('fullscreenButton'); // Removed fullscreen button


        let playerX = 50;
        let playerY = 0;
        // playerWidth and playerHeight will be updated dynamically based on rendered size
        let playerWidth = 0; 
        let playerHeight = 0;
        let playerVelocityY = 0;
        const currentGravity = 0.5;
        
        // Player movement speeds
        const desktopMoveSpeed = 5;
        const mobileMoveSpeed = 3; // Slower movement for mobile
        const desktopJumpStrength = 12;
        const mobileJumpStrength = 8; // Lower jump for mobile

        let isOnBuilding = false;
        let buildings = [];
        let collectibles = []; // Array to store active collectibles
        let crackheads = []; // Array to store active crackhead character
        let score = 0;
        const scorePerJump = 1000;

        // Timer variables
        let gameStartTime = 0;
        let elapsedTime = 0;
        let animationFrameId = null; // To store the requestAnimationFrame ID

        // Base building dimensions for desktop
        const baseBuildingSpawnThreshold = 200;
        const baseMinBuildingWidth = 80;
        const baseMaxBuildingWidth = 150;
        const baseMinBuildingHeight = 150;
        const baseMaxBuildingHeight = 400;
        const baseBuildingGapMin = 100;
        const baseBuildingGapMax = 200;
        const baseMinHeightDiff = 30;
        const baseMaxHeightDiff = 100;

        // Mobile specific building dimensions (adjusted to be smaller)
        const MOBILE_MIN_BUILDING_WIDTH = 40;
        const MOBILE_MAX_BUILDING_WIDTH = 75;
        const MOBILE_MIN_BUILDING_HEIGHT = 75;
        const MOBILE_MAX_BUILDING_HEIGHT = 200;
        const MOBILE_BUILDING_GAP_MIN = 60; /* Doubled from 30 */
        const MOBILE_BUILDING_GAP_MAX = 120; /* Doubled from 60 */
        const MOBILE_MIN_HEIGHT_DIFF = 10;
        const MOBILE_MAX_HEIGHT_DIFF = 30;

        // Desktop window dimensions
        const DESKTOP_WINDOW_SIZE = 15;
        const DESKTOP_WINDOW_SPACING = 10;
        const DESKTOP_HORIZONTAL_PADDING = 20;
        const DESKTOP_VERTICAL_PADDING = 20;

        // Mobile window dimensions (adjusted to be smaller)
        const MOBILE_WINDOW_SIZE = 8; /* Smaller window size for mobile */
        const MOBILE_WINDOW_SPACING = 5; /* Smaller window spacing for mobile */
        const MOBILE_HORIZONTAL_PADDING = 10; /* Reduced padding for mobile windows */
        const MOBILE_VERTICAL_PADDING = 10; /* Reduced padding for mobile windows */

        const difficultyInterval = 5000;
        const maxDifficultyLevels = 10;

        const yellowWindowStartLevel = 1;
        const yellowWindowInitialProbability = 0.16;
        const yellowWindowIncreasePerLevel = 0.05;
        const maxYellowWindowProbability = 0.5;
        let currentYellowWindowProbability = 0;
            
        const GRACE_PERIOD_MIN_MS = 1500;
        const GRACE_PERIOD_MAX_MS = 2000;
        const LETHAL_PHASE_MAX_MS = 4000;
        const SAFE_PHASE_MIN_MS = 1500;
        const SAFE_PHASE_MAX_MS = 3000;

        // Crackhead specific constants
        const CRACKHEAD_IMAGE_URL = 'https://cdn.shopify.com/s/files/1/0937/6061/8760/files/crackhead.png?v=1751871379';
        const CRACKHEAD_SOUND_URL = 'https://cdn.shopify.com/s/files/1/0937/6061/8760/files/Bouchla_Varna_mp3cut.net.mp3?v=1751870701';
        const CRACKHEAD_SPAWN_PROBABILITY = 0.15; // Increased to 15%
        const CRACKHEAD_SOUND_DELAY = 1500; // 1.5 seconds delay before sound plays
        const CRACKHEAD_SINK_DELAY = 1500; // 1.5 seconds delay after sound before sinking (Total 3s after spawn)
        const CRACKHEAD_SINK_SPEED_MULTIPLIER = 120; // Adjusted for much faster sinking (approx 1 second to fall screen height)

        let gameRunning = false; // Game starts paused, waiting for user to click "Hrat o polo"
        let lastSpawnedBuildingX = 0;
        let keysPressed = {};
        let lastLandedBuilding = null;
        let hasInteracted = false; // To ensure audio plays after user interaction
        let startScreenKeyListener = null; // To store the keydown listener for the start screen

        // Define collectible types with image URLs, width, and height
        const collectibleTypes = [
            { value: 600, imageUrl: 'https://cdn.shopify.com/s/files/1/0937/6061/8760/files/injection.png?v=1751807569', width: 40, height: 40 },
            { value: 1000, imageUrl: 'https://cdn.shopify.com/s/files/1/0937/6061/8760/files/crack.png?v=1751807546', width: 45, height: 45 },
            { value: 1200, imageUrl: 'https://cdn.shopify.com/s/files/1/0937/6061/8760/files/polo.png?v=1751807587', width: 50, height: 50 }
        ];
        const collectibleSpawnProbability = 0.2; // 20% chance for a collectible to spawn on a new building

        /**
         * Creates a new building element and adds it to the game.
         * @param {number} x - The x-position of the building.
         * @param {number} width - The width of the building.
         * @param {number} height - The height of the building.
         * @param {boolean} isInitial - True if this is one of the initial buildings.
         */
        function createBuilding(x, width, height, isInitial = false) {
            const building = document.createElement('div');
            building.classList.add('building');
            building.style.left = `${x}px`;
            building.style.width = `${width}px`;
            building.style.height = `${height}px`;
            gameContainer.appendChild(building);

            let isDangerousBuilding = false;
            // Only new buildings can be dangerous (not initial ones)
            if (!isInitial && currentYellowWindowProbability > 0 && Math.random() < currentYellowWindowProbability) {
                isDangerousBuilding = true;
            }

            const newBuilding = {
                element: building,
                x: x,
                width: width,
                height: height,
                isDangerous: isDangerousBuilding,
                windowElements: [],
                cycleState: 'normal_safe', // Default for all, even if not dangerous
                nextStateChangeTime: 0,
                hasAwardedScore: false, // New property to track if score has been awarded for this building
            };

            if (isDangerousBuilding) {
                newBuilding.cycleState = 'initial_yellow_grace';
                newBuilding.nextStateChangeTime = performance.now() + (Math.random() * (GRACE_PERIOD_MAX_MS - GRACE_PERIOD_MIN_MS) + GRACE_PERIOD_MIN_MS);
            }
            
            buildings.push(newBuilding);
            addWindowsToBuilding(newBuilding, isDangerousBuilding);

            // Randomly spawn a collectible on this building if it's not an initial building
            if (!isInitial && Math.random() < collectibleSpawnProbability) {
                spawnCollectible(newBuilding);
            }

            // Randomly spawn a crackhead on this building if it's not an initial building and no collectible spawned
            // Ensure crackhead doesn't spawn on the same building as a collectible
            const hasCollectible = collectibles.some(c => c.onBuilding === newBuilding); // Assuming collectible also stores onBuilding
            if (!isInitial && !hasCollectible && Math.random() < CRACKHEAD_SPAWN_PROBABILITY) {
                spawnCrackhead(newBuilding);
            }

            if (isInitial) {
                lastSpawnedBuildingX = x + width;
            }
        }

        /**
         * Adds windows to a given building element.
         * @param {object} buildingObj - The building object containing its element and properties.
         * @param {boolean} isDangerous - True if the building is dangerous (windows will be yellow).
         */
        function addWindowsToBuilding(buildingObj, isDangerous) {
            const buildingElement = buildingObj.element;
            const buildingWidth = buildingObj.width;
            const buildingHeight = buildingObj.height;
            const isMobile = window.innerWidth <= 768;

            // Determine window dimensions based on screen size
            const currentWindowSize = isMobile ? MOBILE_WINDOW_SIZE : DESKTOP_WINDOW_SIZE;
            const currentWindowSpacing = isMobile ? MOBILE_WINDOW_SPACING : DESKTOP_WINDOW_SPACING;
            const currentHorizontalPadding = isMobile ? MOBILE_HORIZONTAL_PADDING : DESKTOP_HORIZONTAL_PADDING;
            const currentVerticalPadding = isMobile ? MOBILE_VERTICAL_PADDING : DESKTOP_VERTICAL_PADDING;

            const availableWidth = buildingWidth - (2 * currentHorizontalPadding);
            const availableHeight = buildingHeight - (2 * currentVerticalPadding);

            if (availableWidth <= 0 || availableHeight <= 0) return;

            const numWindowsX = Math.floor(availableWidth / (currentWindowSize + currentWindowSpacing));
            const numWindowsY = Math.floor(availableHeight / (currentWindowSize + currentWindowSpacing));

            if (numWindowsX === 0 || numWindowsY === 0) return;

            const actualWindowsWidth = numWindowsX * currentWindowSize + (numWindowsX - 1) * currentWindowSpacing;
            const actualWindowsHeight = numWindowsY * currentWindowSize + (numWindowsY - 1) * currentWindowSpacing;

            const offsetX = (availableWidth - actualWindowsWidth) / 2;
            const offsetY = (availableHeight - actualWindowsHeight) / 2;

            for (let i = 0; i < numWindowsY; i++) {
                for (let j = 0; j < numWindowsX; j++) {
                    if (Math.random() > 0.3) { // Randomly skip some windows for variety
                        const window = document.createElement('div');
                        window.classList.add('building-window');
                        if (isDangerous) {
                            window.classList.add('yellow');
                        }
                        window.style.width = `${currentWindowSize}px`;
                        window.style.height = `${currentWindowSize}px`;
                        window.style.left = `${currentHorizontalPadding + offsetX + j * (currentWindowSize + currentWindowSpacing)}px`;
                        window.style.bottom = `${currentVerticalPadding + offsetY + i * (currentWindowSize + currentWindowSpacing)}px`;
                        buildingElement.appendChild(window);
                        buildingObj.windowElements.push(window);
                    }
                }
            }
        }

        /**
         * Spawns a collectible on top of a given building.
         * @param {object} buildingObj - The building object on which to spawn the collectible.
         */
        function spawnCollectible(buildingObj) {
            const typeIndex = Math.floor(Math.random() * collectibleTypes.length);
            const collectibleType = collectibleTypes[typeIndex];

            const collectibleElement = document.createElement('img'); // Changed to img element
            collectibleElement.classList.add('collectible');
            collectibleElement.src = collectibleType.imageUrl; // Set image source
            collectibleElement.style.width = `${collectibleType.width}px`;
            collectibleElement.style.height = `${collectibleType.height}px`;
            collectibleElement.onerror = function() { // Fallback for image loading errors
                this.src = `https://placehold.co/${collectibleType.width}x${collectibleType.height}/000/fff?text=Error`;
            };

            // Position collectible horizontally centered on the building, on top of it
            const collectibleX = buildingObj.x + (buildingObj.width / 2) - (collectibleType.width / 2);
            const collectibleY = buildingObj.height; // On top of the building

            collectibleElement.style.left = `${collectibleX}px`;
            collectibleElement.style.bottom = `${collectibleY}px`;
            gameContainer.appendChild(collectibleElement);

            collectibles.push({
                element: collectibleElement,
                x: collectibleX,
                y: collectibleY,
                width: collectibleType.width,
                height: collectibleType.height,
                value: collectibleType.value,
                onBuilding: buildingObj // Store reference to the building
            });
        }

        /**
         * Spawns a crackhead character on top of a given building.
         * @param {object} buildingObj - The building object on which to spawn the crackhead.
         */
        function spawnCrackhead(buildingObj) {
            const crackheadElement = document.createElement('img');
            crackheadElement.classList.add('crackhead');
            crackheadElement.src = CRACKHEAD_IMAGE_URL;
            // Set crackhead dimensions to match the player's current rendered dimensions
            crackheadElement.style.width = `${playerWidth}px`; 
            crackheadElement.style.height = `${playerHeight}px`; 
            crackheadElement.onerror = function() {
                this.src = `https://placehold.co/${playerWidth}x${playerHeight}/800/fff?text=Crackhead`;
            };

            // Position crackhead horizontally centered on the building, on top of it
            const crackheadX = buildingObj.x + (buildingObj.width / 2) - (playerWidth / 2);
            const crackheadY = buildingObj.height; // On top of the building

            crackheadElement.style.left = `${crackheadX}px`;
            crackheadElement.style.bottom = `${crackheadY}px`;
            gameContainer.appendChild(crackheadElement);

            const newCrackhead = {
                element: crackheadElement,
                x: crackheadX,
                y: crackheadY,
                initialY: crackheadY, // Store initial Y for relative sinking
                width: playerWidth, // Use current player width for crackhead logic
                height: playerHeight, // Use current player height for crackhead logic
                state: 'static', // 'static' initially, then 'sinking'
                onBuilding: buildingObj, // Reference to the building it's standing on
                animationStartTime: 0, // To track animation start time for sinking
                animationTimeoutId: null // To clear pending timeouts
            };
            crackheads.push(newCrackhead);

            // Play crackhead spawn sound after a delay, then trigger sinking after another delay
            setTimeout(() => {
                crackheadAudio.currentTime = 0; // Rewind to start
                crackheadAudio.play().catch(e => console.log("Crackhead audio autoplay prevented:", e));

                // Set timeout for crackhead to start sinking after the sound plays
                newCrackhead.animationTimeoutId = setTimeout(() => {
                    newCrackhead.state = 'sinking';
                    newCrackhead.animationStartTime = performance.now(); // Record time when sinking starts
                }, CRACKHEAD_SINK_DELAY);

            }, CRACKHEAD_SOUND_DELAY);
        }

        /**
         * Initializes the starting buildings for the game.
         */
        function initializeBuildings() {
            const containerWidth = gameContainer.offsetWidth;
            const isMobile = window.innerWidth <= 768; // Check if on mobile

            // Determine building dimensions based on screen size
            const currentMinBuildingWidth = isMobile ? MOBILE_MIN_BUILDING_WIDTH : baseMinBuildingWidth;
            const currentMaxBuildingWidth = isMobile ? MOBILE_MAX_BUILDING_WIDTH : baseMaxBuildingWidth;
            const currentMinBuildingHeight = isMobile ? MOBILE_MIN_BUILDING_HEIGHT : baseMinBuildingHeight;
            const currentMaxBuildingHeight = isMobile ? MOBILE_MAX_BUILDING_HEIGHT : baseMaxBuildingHeight;
            const currentMinHeightDiff = isMobile ? MOBILE_MIN_HEIGHT_DIFF : baseMinHeightDiff;
            const currentMaxHeightDiff = isMobile ? MOBILE_MAX_HEIGHT_DIFF : baseMaxHeightDiff;
            const currentBuildingGapMin = isMobile ? MOBILE_BUILDING_GAP_MIN : baseBuildingGapMin;
            const currentBuildingGapMax = isMobile ? MOBILE_BUILDING_GAP_MAX : baseBuildingGapMax;


            score = 0; // Always start from 0 with no persistence
            gameStartTime = performance.now(); // Start the timer

            // Clear existing buildings and collectibles
            buildings.forEach(b => b.element.remove());
            buildings = [];
            collectibles.forEach(c => c.element.remove());
            collectibles = [];
            crackheads.forEach(ch => {
                clearTimeout(ch.animationTimeoutId); // Clear any pending animation timeouts
                ch.element.remove();
            });
            crackheads = [];

            const firstBuildingWidth = Math.random() * (currentMaxBuildingWidth - currentMinBuildingWidth) + currentMinBuildingWidth;
            const firstBuildingHeight = Math.random() * (currentMaxBuildingHeight - currentMinBuildingHeight) + currentMinBuildingHeight;
            const initialPlayerBuildingX = playerX - (firstBuildingWidth / 2) + (playerWidth / 2);
            createBuilding(initialPlayerBuildingX, firstBuildingWidth, firstBuildingHeight, true);
            
            buildings[0].isDangerous = false;
            buildings[0].windowElements.forEach(win => win.classList.remove('yellow'));
            buildings[0].cycleState = 'normal_safe';
            buildings[0].nextStateChangeTime = 0;
            buildings[0].hasAwardedScore = false; // Reset score flag for initial building

            player.style.bottom = `${firstBuildingHeight}px`;
            playerY = firstBuildingHeight;
            isOnBuilding = true;
            lastLandedBuilding = buildings[0];

            // Fill the initial screen with buildings
            while (lastSpawnedBuildingX < containerWidth) {
                const prevBuilding = buildings[buildings.length - 1];
                const gap = Math.random() * (currentBuildingGapMax - currentBuildingGapMin) + currentBuildingGapMin;
                const nextX = prevBuilding.x + prevBuilding.width + gap;

                let nextHeight = prevBuilding.height + (Math.random() * (currentMaxHeightDiff - currentMinHeightDiff) + currentMinHeightDiff) * (Math.random() > 0.5 ? 1 : -1);
                nextHeight = Math.max(currentMinBuildingHeight, Math.min(currentMaxBuildingHeight, nextHeight));

                const nextWidth = Math.random() * (currentMaxBuildingWidth - currentMinBuildingWidth) + currentMinBuildingWidth;

                createBuilding(nextX, nextWidth, nextHeight, true);
                lastSpawnedBuildingX = nextX + nextWidth;
            }
        }

        /**
         * Spawns new buildings as the player progresses.
         */
        function spawnBuildings() {
            const containerWidth = gameContainer.offsetWidth;
            const isMobile = window.innerWidth <= 768; // Check if on mobile

            // Determine building dimensions based on screen size
            const currentMinBuildingWidth = isMobile ? MOBILE_MIN_BUILDING_WIDTH : baseMinBuildingWidth;
            const currentMaxBuildingWidth = isMobile ? MOBILE_MAX_BUILDING_WIDTH : baseMaxBuildingWidth;
            const currentMinBuildingHeight = isMobile ? MOBILE_MIN_BUILDING_HEIGHT : baseMinBuildingHeight;
            const currentMaxBuildingHeight = isMobile ? MOBILE_MAX_BUILDING_HEIGHT : baseMaxBuildingHeight;
            const currentMinHeightDiff = isMobile ? MOBILE_MIN_HEIGHT_DIFF : baseMinHeightDiff;
            const currentMaxHeightDiff = isMobile ? MOBILE_MAX_HEIGHT_DIFF : baseMaxHeightDiff;
            const currentBuildingGapMin = isMobile ? MOBILE_BUILDING_GAP_MIN : baseBuildingGapMin;
            const currentBuildingGapMax = isMobile ? MOBILE_BUILDING_GAP_MAX : baseBuildingGapMax;

            while (lastSpawnedBuildingX < containerWidth + baseBuildingSpawnThreshold) {
                const prevBuilding = buildings[buildings.length - 1];
                const gap = Math.random() * (currentBuildingGapMax - currentBuildingGapMin) + currentBuildingGapMin;
                const nextX = lastSpawnedBuildingX + gap;

                let nextHeight = prevBuilding.height + (Math.random() * (currentMaxHeightDiff - currentMinHeightDiff) + currentMinHeightDiff) * (Math.random() > 0.5 ? 1 : -1);
                nextHeight = Math.max(currentMinBuildingHeight, Math.min(currentMaxBuildingHeight, nextHeight));

                const nextWidth = Math.random() * (currentMaxBuildingWidth - currentMinBuildingWidth) + currentMinBuildingWidth;

                createBuilding(nextX, nextWidth, nextHeight);
                lastSpawnedBuildingX = nextX + nextWidth;
            }
        }

        /**
         * The main game loop, updated on each animation frame.
         */
        function gameLoop() {
            if (!gameRunning) {
                // If game is not running, cancel any pending animation frame
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }

            // Update playerWidth and playerHeight based on current rendered size
            playerWidth = player.offsetWidth;
            playerHeight = player.offsetHeight;

            const currentTime = performance.now();
            elapsedTime = currentTime - gameStartTime; // Update elapsed time

            // Update dangerous building states (yellow windows)
            buildings.forEach(building => {
                if (building.isDangerous && currentTime >= building.nextStateChangeTime) {
                    if (building.cycleState === 'initial_yellow_grace') {
                        building.cycleState = 'lethal_yellow_active';
                        building.nextStateChangeTime = currentTime + (Math.random() * LETHAL_PHASE_MAX_MS);
                    }
                    else if (building.cycleState === 'lethal_yellow_active') {
                        building.cycleState = 'normal_safe';
                        building.windowElements.forEach(win => win.classList.remove('yellow'));
                        building.nextStateChangeTime = currentTime + (Math.random() * (SAFE_PHASE_MAX_MS - SAFE_PHASE_MIN_MS) + SAFE_PHASE_MIN_MS);
                    } else if (building.cycleState === 'normal_safe') {
                        building.cycleState = 'lethal_yellow_active';
                        building.windowElements.forEach(win => win.classList.add('yellow'));
                        building.nextStateChangeTime = currentTime + (Math.random() * LETHAL_PHASE_MAX_MS);
                    }
                }
            });

            // Update crackhead positions if sinking
            crackheads.forEach(crackhead => {
                if (crackhead.state === 'sinking') {
                    // Calculate how much time has passed since sinking started
                    const sinkElapsedTime = currentTime - crackhead.animationStartTime;
                    // Calculate current sink amount based on time, ensuring continuous downward motion
                    const sinkAmount = (sinkElapsedTime / 1000) * (currentGravity * 10 * CRACKHEAD_SINK_SPEED_MULTIPLIER);
                    crackhead.y = crackhead.initialY - sinkAmount; // Subtract to move downwards
                    crackhead.element.style.bottom = `${crackhead.y}px`;
                }
            });

            // Apply gravity and update player position
            playerVelocityY -= currentGravity;
            playerY += playerVelocityY;

            player.style.bottom = `${playerY}px`;
            player.style.left = `${playerX}px`;

            isOnBuilding = false;
            let currentBuilding = null;

            // Check for player collision with buildings
            for (let i = 0; i < buildings.length; i++) {
                const building = buildings[i];
                const buildingBottom = building.height;
                const buildingLeft = building.x;
                const buildingRight = building.x + building.width;

                // Check if player is horizontally aligned with the building
                if (playerX + playerWidth > buildingLeft && playerX < buildingRight) {
                    // Check if player is landing on the building
                    if (playerY <= buildingBottom && playerY + playerHeight > buildingBottom) {
                        if (playerVelocityY < 0) { // Only land if falling
                            playerY = buildingBottom;
                            playerVelocityY = 0;
                            isOnBuilding = true;
                            currentBuilding = building;

                            // Award score for landing on a new building only if it hasn't awarded score yet
                            if (!currentBuilding.hasAwardedScore) {
                                score += scorePerJump;
                                updateScore();
                                currentBuilding.hasAwardedScore = true; // Mark building as having awarded score
                            }
                            lastLandedBuilding = currentBuilding;
                            break; // Player found a building to land on, stop checking others
                        }
                    }
                }
            }

            // Check for player falling off the screen
            if (playerY < -playerHeight) {
                gameOver("Spadl jsi z paneláku!"); // Specific death reason
                return; // End game loop immediately
            }

            // Determine current move speed based on screen size
            const currentMoveSpeed = window.innerWidth <= 768 ? mobileMoveSpeed : desktopMoveSpeed;
            
            // Handle player movement based on keys pressed
            if (keysPressed.ArrowLeft) {
                movePlayer('left', currentMoveSpeed);
            }
            if (keysPressed.ArrowRight) {
                movePlayer('right', currentMoveSpeed);
            }
            if (keysPressed.ArrowUp && isOnBuilding && playerVelocityY === 0) {
                jump();
            }

            // Implement horizontal scrolling of the game world
            const containerWidth = gameContainer.offsetWidth;
            const scrollThreshold = containerWidth * 0.4; // Scroll when player is past 40% of screen width

            if (playerX > scrollThreshold && (keysPressed.ArrowRight || (playerX > gameContainer.offsetWidth * 0.7 && isOnBuilding))) {
                const scrollAmount = (playerX - scrollThreshold) * 0.1;
                // Scroll buildings
                buildings.forEach(building => {
                    building.x -= scrollAmount;
                    building.element.style.left = `${building.x}px`;
                });
                // Scroll collectibles
                collectibles.forEach(collectible => {
                    collectible.x -= scrollAmount;
                    collectible.element.style.left = `${collectible.x}px`;
                });
                // Scroll crackheads
                crackheads.forEach(crackhead => {
                    crackhead.x -= scrollAmount;
                    crackhead.element.style.left = `${crackhead.x}px`;
                });
                lastSpawnedBuildingX -= scrollAmount;
                playerX -= scrollAmount; // Keep player relatively in place on screen
            }

            // Remove off-screen buildings
            buildings = buildings.filter(building => {
                if (building.x + building.width < -100) { // Remove if completely off-screen to the left
                    building.element.remove();
                    return false;
                }
                return true;
            });

            // Check for player collision with collectibles
            collectibles = collectibles.filter(collectible => {
                // Check if collectible is off-screen
                if (collectible.x + collectible.width < -100) {
                    collectible.element.remove();
                    return false;
                }

                // Check for collision with player
                if (
                    playerX < collectible.x + collectible.width &&
                    playerX + playerWidth > collectible.x &&
                    playerY < collectible.y + collectible.height &&
                    playerY + playerHeight > collectible.y
                ) {
                    score += collectible.value; // Add collectible value to score
                    updateScore(); // Update score display
                    collectible.element.remove(); // Remove collectible from DOM
                    return false; // Remove from collectibles array
                }
                return true; // Keep collectible in array
            });

            // Check for player collision with crackheads (lethal on collision)
            crackheads = crackheads.filter(crackhead => {
                // Check if crackhead is off-screen
                if (crackhead.x + crackhead.width < -100 || crackhead.y < -crackhead.height) { // Remove if scrolled off or sunk below screen
                    clearTimeout(crackhead.animationTimeoutId); // Clear any pending animation timeouts
                    crackhead.element.remove();
                    return false;
                }

                // Check for collision with player
                if (
                    playerX < crackhead.x + crackhead.width &&
                    playerX + playerWidth > crackhead.x &&
                    playerY < crackhead.y + crackhead.height &&
                    playerY + playerHeight > crackhead.y
                ) {
                    gameOver("Brasko zabil tě crackhead!"); // Game over on collision
                    clearTimeout(crackhead.animationTimeoutId); // Clear any pending animation timeouts
                    crackhead.element.remove(); // Remove crackhead from DOM
                    return false; // Remove from crackheads array
                }
                return true; // Keep crackhead in array
            });

            spawnBuildings(); // Spawn new buildings as needed
            animationFrameId = requestAnimationFrame(gameLoop); // Continue the game loop
        }

        /**
         * Makes the player jump.
         */
        function jump() {
            const currentJumpStrength = window.innerWidth <= 768 ? mobileJumpStrength : desktopJumpStrength;
            if (isOnBuilding && playerVelocityY === 0) {
                playerVelocityY = currentJumpStrength;
                isOnBuilding = false;
            }
        }

        /**
         * Moves the player horizontally.
         * @param {string} direction - 'left' or 'right'.
         * @param {number} speed - The speed to move the player.
         */
        function movePlayer(direction, speed) {
            const gameContainerWidth = gameContainer.offsetWidth;
            if (direction === 'left') {
                playerX = Math.max(0, playerX - speed);
            } else if (direction === 'right') {
                playerX = Math.min(gameContainerWidth - playerWidth, playerX + speed);
            }
            player.style.left = `${playerX}px`;
        }

        /**
         * Updates the score display.
         */
        function updateScore() {
            scoreDisplay.textContent = `Score: ${score}`;
            checkDifficulty();
        }

        /**
         * Adjusts game difficulty based on score.
         */
        function checkDifficulty() {
            const difficultyLevel = Math.floor(score / difficultyInterval);
            if (difficultyLevel > maxDifficultyLevels) return;

            if (difficultyLevel >= yellowWindowStartLevel) {
                currentYellowWindowProbability = yellowWindowInitialProbability + (yellowWindowIncreasePerLevel * (difficultyLevel - yellowWindowStartLevel + 1));
                currentYellowWindowProbability = Math.min(maxYellowWindowProbability, currentYellowWindowProbability);
            } else {
                currentYellowWindowProbability = 0;
            }
        }

        /**
         * Shows the message box with specified content and buttons.
         * @param {string} msg - The main message text.
         * @param {string} type - 'start' for initial message, 'gameOver' for game over, 'info' for general messages.
         * @param {string} deathReason - Specific reason for death (only for 'gameOver' type).
         */
        function showMessage(msg, type = 'info', deathReason = '') {
            // Hide all elements first
            instagramNicknameInput.classList.add('hidden');
            submitNicknameButton.classList.add('hidden');
            startGameButton.classList.add('hidden');
            restartGameButton.classList.add('hidden');
            timePlayedDisplay.classList.add('hidden');
            deathReasonDisplay.classList.add('hidden');
            startInstruction.classList.add('hidden'); // Hide start instruction
            prizeText.classList.add('hidden'); // Hide prize text
            closeButton.classList.add('hidden'); // Hide close button by default
            messageBox.classList.remove('start-screen'); // Remove start-screen class
            instagramShareModal.style.display = 'none'; // Ensure Instagram modal is hidden

            // Stop the game loop when message box is shown
            gameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            if (type === 'start') {
                gameContainer.classList.add('start-screen-cover'); // Set game cover as background
                messageBox.classList.add('start-screen'); // Add specific styling for start screen popup

                messageText.textContent = "PANEL JUMPER"; // Game title
                startInstruction.textContent = "Press [Space/Up Arrow] or click 'Hrat o polo' to start"; // Start instruction
                prizeText.textContent = "Hráč s největším score dostane polo za free!"; // Prize text

                startInstruction.classList.remove('hidden');
                prizeText.classList.remove('hidden');
                startGameButton.classList.remove('hidden');
                playRestartButton.textContent = "Play"; // Set to Play on start screen

                // Add keyboard listener for start screen
                if (!startScreenKeyListener) {
                    startScreenKeyListener = (e) => {
                        if (e.code === 'Space' || e.code === 'ArrowUp') {
                            startGameButton.click(); // Simulate button click
                            document.removeEventListener('keydown', startScreenKeyListener); // Remove listener
                            startScreenKeyListener = null;
                        }
                    };
                    document.addEventListener('keydown', startScreenKeyListener);
                }

            } else if (type === 'gameOver') {
                gameContainer.classList.remove('start-screen-cover'); // Remove cover background
                
                deathReasonDisplay.textContent = deathReason; // Display specific death reason
                deathReasonDisplay.classList.remove('hidden');

                // Display final score
                finalScoreDisplay.textContent = `Skóre: ${score}`;
                finalScoreDisplay.classList.remove('hidden');

                instagramNicknameInput.classList.remove('hidden');
                submitNicknameButton.classList.remove('hidden');
                restartGameButton.classList.remove('hidden');
                messageText.textContent = "Pro zapojení si toto dej na story a označ @cbloc_"; // Game over instruction

                // Format and display time played below restart button
                const totalSeconds = Math.floor(elapsedTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timePlayedDisplay.textContent = `Čas hry: ${minutes}m ${seconds}s`;
                timePlayedDisplay.classList.remove('hidden');
                playRestartButton.textContent = "Restart"; // Set to Restart on game over
            } else if (type === 'info') {
                gameContainer.classList.remove('start-screen-cover'); // Remove cover background
                restartGameButton.classList.remove('hidden');
                messageText.textContent = msg; // General info message
                playRestartButton.textContent = "Restart"; // Set to Restart for info messages
            } else if (type === 'leaderboard') {
                gameContainer.classList.remove('start-screen-cover');
                messageText.innerHTML = msg; // msg will be the leaderboard HTML
                closeButton.classList.remove('hidden'); // Show the dedicated close button
                playRestartButton.textContent = "Play"; // Set to Play when leaderboard is open
            }
            messageBox.style.display = 'flex'; // Show message box
        }

        /**
         * Hides the message box and resumes the game.
         */
        function hideMessage() {
            messageBox.style.display = 'none';
            instagramShareModal.style.display = 'none'; // Ensure Instagram modal is hidden
            gameContainer.classList.remove('start-screen-cover');
            // Remove start screen key listener if it's still active
            if (startScreenKeyListener) {
                document.removeEventListener('keydown', startScreenKeyListener);
                startScreenKeyListener = null;
            }
            gameRunning = true; // Resume game
            if (!animationFrameId) { // Only request if not already running
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            playRestartButton.textContent = "Restart"; // Set to Restart when game is active
        }

        /**
         * Closes the message box without restarting the game.
         */
        function closeMessageBox() {
            hideMessage();
        }

        /**
         * Shows the Instagram share modal.
         * @param {number} finalScore - The final score to display.
         * @param {number} finalTime - The final elapsed time in milliseconds to display.
         */
        function showInstagramModal(finalScore, finalTime) {
            // Hide the regular message box first
            messageBox.style.display = 'none';
            gameRunning = false; // Ensure game is paused
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            instagramScoreDisplay.textContent = `Score: ${finalScore}`;
            const totalSeconds = Math.floor(finalTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            instagramTimeDisplay.textContent = `Time: ${minutes}m ${seconds}s`;

            instagramShareModal.style.display = 'flex'; // Show the Instagram modal
            playRestartButton.textContent = "Restart"; // Set to Restart when Instagram modal is open
        }

        /**
         * Handles game over state, logs message, shows popup.
         * @param {string} message - The game over message (reason for death).
         */
        function gameOver(message) {
            console.log("Game Over:", message); // Log the game over message
            showMessage(message, 'gameOver', message); // Pass the death reason to showMessage
        }

        /**
         * Sends the score and nickname and time to the PHP backend.
         * @param {string} nickname - The Instagram nickname.
         * @param {number} currentScore - The score to save.
         * @param {number} timePlayed - The elapsed time in milliseconds.
         */
        async function saveScoreToBackend(nickname, currentScore, timePlayed) {
            // Format time for display/storage
            const totalSeconds = Math.floor(timePlayed / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedTime = `${minutes}m ${seconds}s`;

            try {
                const response = await fetch('https://8ffdb10b-e4b8-4596-82ec-c72d21700d04-00-3ka02576z8goq.riker.replit.dev/save_score.php', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: nickname, score: currentScore, time: formattedTime }) // Include time
                });

                if (!response.ok) {
                    throw new Error('Chyba serveru: ' + response.statusText);
                }
                const message = await response.text();
                // Instead of showMessage, show the new Instagram modal
                showInstagramModal(currentScore, timePlayed); 
            } catch (error) {
                console.error('Chyba při ukládání skóre:', error);
                showMessage('Chyba při ukládání: ' + error.message, 'info'); // Show error message in original modal
            }
        }

        /**
         * Fetches and displays the top 5 scores on the leaderboard.
         */
        async function showLeaderboard() {
            gameRunning = false; // Pause game
            showMessage("Loading Leaderboard...", 'leaderboard'); // Show loading message

            try {
                const response = await fetch('https://8ffdb10b-e4b8-4596-82ec-c72d21700d04-00-3ka02576z8goq.riker.replit.dev/load_leaderboard.php', {
                    method: 'GET',
                    credentials: 'include'
                });

                if (!response.ok) {
                    throw new Error('Server error: ' + response.statusText);
                }
                const topScores = await response.json();

                let leaderboardHtml = '<h2 class="text-2xl font-bold mb-4">Top 5 Scores</h2>';
                if (topScores.length > 0) {
                    leaderboardHtml += '<ol class="text-left mx-auto list-decimal list-inside">';
                    topScores.forEach((score, index) => {
                        leaderboardHtml += `<li class="my-1 text-lg">Score: ${score}</li>`;
                    });
                    leaderboardHtml += '</ol>';
                } else {
                    leaderboardHtml += '<p>No scores available yet.</p>';
                }
                showMessage(leaderboardHtml, 'leaderboard'); // Display leaderboard
            } catch (error) {
                console.error('Error fetching leaderboard:', error);
                showMessage('Failed to load leaderboard. Please try again later. Error: ' + error.message, 'leaderboard');
            }
        }


        /**
         * Resets game state and restarts the game.
         */
        function restartGame() {
            // Cancel any existing animation frame to prevent multiple loops
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Remove all existing buildings from DOM and array
            buildings.forEach(b => b.element.remove());
            buildings = [];
            // Remove all existing collectibles from DOM and array
            collectibles.forEach(c => c.element.remove());
            collectibles = [];
            // Remove all existing crackheads from DOM and array
            crackheads.forEach(ch => {
                clearTimeout(ch.animationTimeoutId); // Clear any pending animation timeouts
                ch.element.remove();
            });
            crackheads = [];

            playerX = 50;
            playerY = 0;
            playerVelocityY = 0;
            score = 0; // Reset score on restart
            gameStartTime = performance.now(); // Reset timer on restart
            elapsedTime = 0; // Reset elapsed time

            currentYellowWindowProbability = 0;

            isOnBuilding = false;
            lastLandedBuilding = null;
            lastSpawnedBuildingX = 0;
            keysPressed = {};
            
            initializeBuildings();
            player.style.left = `${playerX}px`;

            updateScore();
            hideMessage(); // Hide the message box and start the game loop
        }

        /**
         * Initializes background audio on first user interaction.
         */
        function initializeAudio() {
            if (!hasInteracted) {
                gameAudio.loop = true;
                gameAudio.volume = 0.5;
                gameAudio.play().catch(e => console.log("Audio autoplay prevented:", e));
                hasInteracted = true;
            }
        }

        // Event listeners for keyboard input
        document.addEventListener('keydown', (e) => { 
            keysPressed[e.code] = true; 
            initializeAudio(); 
        }); 

        document.addEventListener('keyup', (e) => { 
            keysPressed[e.code] = false; 
        }); 

        // Variables for mobile control intervals
        let leftButtonInterval = null; 
        let rightButtonInterval = null; 
        let upButtonActive = false; 

        /**
         * Starts continuous horizontal movement for mobile controls.
         * @param {string} direction - 'left' or 'right'.
         */
        function startHorizontalMove(direction) { 
            keysPressed[direction === 'left' ? 'ArrowLeft' : 'ArrowRight'] = true; 
            if (direction === 'left' && !leftButtonInterval) { 
                leftButtonInterval = setInterval(() => { 
                    if (keysPressed.ArrowLeft && gameRunning) movePlayer('left', mobileMoveSpeed); 
                }, 50); 
            } else if (direction === 'right' && !rightButtonInterval) { 
                rightButtonInterval = setInterval(() => { 
                    if (keysPressed.ArrowRight && gameRunning) movePlayer('right', mobileMoveSpeed); 
                }, 50); 
            } 
        } 

        /**
         * Stops continuous horizontal movement for mobile controls.
         * @param {string} direction - 'left' or 'right'.
         */
        function stopHorizontalMove(direction) { 
            keysPressed[direction === 'left' ? 'ArrowLeft' : 'ArrowRight'] = false; 
            if (direction === 'left' && leftButtonInterval) { 
                clearInterval(leftButtonInterval); 
                leftButtonInterval = null; 
            } else if (direction === 'right' && rightButtonInterval) { 
                clearInterval(rightButtonInterval); 
                rightButtonInterval = null; 
            } 
        } 

        // Mobile control button event listeners (touch and mouse for broader compatibility)
        document.getElementById('upButton').addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            initializeAudio(); 
            if (!upButtonActive) { 
                jump(); 
                upButtonActive = true; 
            } 
        }); 
        document.getElementById('upButton').addEventListener('touchend', () => { 
            upButtonActive = false; 
        }); 
        document.getElementById('upButton').addEventListener('mousedown', (e) => { 
            if (e.button === 0) { 
                initializeAudio(); 
                if (!upButtonActive) { 
                    jump(); 
                    upButtonActive = true; 
                } 
            } 
        }); 
        document.getElementById('upButton').addEventListener('mouseup', (e) => { 
            if (e.button === 0) upButtonActive = false; 
        }); 

        document.getElementById('leftButton').addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            initializeAudio(); 
            startHorizontalMove('left'); 
        }); 
        document.getElementById('leftButton').addEventListener('touchend', () => { 
            stopHorizontalMove('left'); 
        }); 
        document.getElementById('leftButton').addEventListener('mousedown', (e) => { 
            if (e.button === 0) { 
                initializeAudio(); 
                startHorizontalMove('left'); 
            } 
        }); 
        document.getElementById('leftButton').addEventListener('mouseup', (e) => { 
            if (e.button === 0) stopHorizontalMove('left'); 
        }); 

        document.getElementById('rightButton').addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            initializeAudio(); 
            startHorizontalMove('right'); 
        }); 
        document.getElementById('rightButton').addEventListener('touchend', () => { 
            stopHorizontalMove('right'); 
        }); 
        document.getElementById('rightButton').addEventListener('mousedown', (e) => { 
            if (e.button === 0) { 
                initializeAudio(); 
                startHorizontalMove('right'); 
            } 
        }); 
        document.getElementById('rightButton').addEventListener('mouseup', (e) => { 
            if (e.button === 0) stopHorizontalMove('right'); 
        }); 

        // Event listeners for message box buttons
        startGameButton.addEventListener('click', () => {
            initializeAudio(); // Ensure audio starts on game start
            initializeBuildings(); // Initialize buildings for a new game
            updateScore();
            hideMessage(); // Start the game
        });

        restartGameButton.addEventListener('click', restartGame);
        closeButton.addEventListener('click', closeMessageBox); // Event listener for the new close button
        instagramCloseButton.addEventListener('click', restartGame); // Instagram modal close button now restarts the game

        submitNicknameButton.addEventListener('click', () => {
            const nickname = instagramNicknameInput.value.trim();
            if (nickname === "") {
                messageText.textContent = "Prosím, zadejte svůj Instagram nickname.";
                return;
            }
            saveScoreToBackend(nickname, score, elapsedTime); // Pass elapsedTime to save function
        });

        // Event listener for the new leaderboard button
        leaderboardButton.addEventListener('click', showLeaderboard);

        // Event listener for the new play/restart button
        playRestartButton.addEventListener('click', () => {
            if (playRestartButton.textContent === "Play") {
                initializeAudio(); // Ensure audio starts on game start
                initializeBuildings();
                updateScore();
                hideMessage();
            } else { // It says "Restart"
                restartGame();
            }
        });

        // Event listener for the new fullscreen button
        /* Removed fullscreen button event listener as the button is removed */
        // fullscreenButton.addEventListener('click', () => {
        //     if (gameContainer.requestFullscreen) {
        //         gameContainer.requestFullscreen();
        //     } else if (gameContainer.mozRequestFullScreen) { /* Firefox */
        //         gameContainer.mozRequestFullScreen();
        //     } else if (gameContainer.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
        //         gameContainer.webkitRequestFullscreen();
        //     } else if (gameContainer.msRequestFullscreen) { /* IE/Edge */
        //         gameContainer.msRequestFullscreen();
        //     }
        // });

        // Initialize game on window load
        window.onload = function() {
            // Show the initial game start message
            showMessage("Hráč s největším score dostane polo za free!", 'start');
        };
    </script>
</body>
</html>
